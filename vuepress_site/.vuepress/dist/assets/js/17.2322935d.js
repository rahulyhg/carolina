(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{161:function(e,r,t){"use strict";t.r(r);var n=t(0),o=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"exceptions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#exceptions","aria-hidden":"true"}},[e._v("#")]),e._v(" Exceptions")]),t("p",[e._v("In a new project, any uncaught\nexceptions that take place during the HTTP request cycle\nshould return an error page to the user.")]),t("h2",{attrs:{id:"relevant-configuration"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#relevant-configuration","aria-hidden":"true"}},[e._v("#")]),e._v(" Relevant Configuration")]),t("p",[e._v("If the value of "),t("code",[e._v("debug")]),e._v(" in "),t("code",[e._v("config/app.js")]),e._v(" is true, the returned information\nwill have a lot of details (including sensitive information).\nDo not have "),t("code",[e._v("debug")]),e._v(" set to true in production as everything, including site\nsecret keys, will be available to a visitor that sees the error page.")]),t("p",[e._v("If the value of "),t("code",[e._v("emitErrors")]),e._v(" in "),t("code",[e._v("config/errors.js")]),e._v(" is true,")]),t("p",[e._v("The function "),t("code",[e._v("respondWithJson")]),e._v(" in "),t("code",[e._v("config/errors.js")]),e._v(' will be called to\ndetermine if the response page should be in JSON instead of the normal HTML\nview. By default, JSON will be used if the route contains the string\n"api/"\nor if the request "Accept" header reads "application/json".')]),t("h2",{attrs:{id:"error-handling"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#error-handling","aria-hidden":"true"}},[e._v("#")]),e._v(" Error Handling")]),t("p",[e._v("When an error takes place anywhere within the request/response cycle,\nit is raised to the "),t("strong",[e._v("Errors Service")]),e._v(" for handling.")]),t("h3",{attrs:{id:"reporting-errors"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reporting-errors","aria-hidden":"true"}},[e._v("#")]),e._v(" Reporting Errors")]),t("p",[e._v("If the "),t("code",[e._v("emitErrors")]),e._v(" property in "),t("code",[e._v("config/errors.js")]),e._v(" is true, the Errors\nService will build an "),t("code",[e._v("ErrorEvent")]),e._v(" using the thrown error, the HttpRequest\nobject, and the HttpResponse object (if the error took place after the\nController returned). That Event will then be fired. By default, the\n"),t("code",[e._v("LogError")]),e._v(" Listener (which will create log events for every error it\nreceives as part of an "),t("code",[e._v("ErrorEvent")]),e._v(") is configured to listed for\n"),t("code",[e._v("ErrorEvent")]),e._v(" Events. You could create your own Listeners and configure\nthem to also listen for and handle "),t("code",[e._v("ErrorEvent")]),e._v(" instances. You would do\nthe configuration in "),t("code",[e._v("config/events.js")]),e._v(".")]),t("h3",{attrs:{id:"rendering-errors"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rendering-errors","aria-hidden":"true"}},[e._v("#")]),e._v(" Rendering Errors")]),t("p",[e._v("After the "),t("code",[e._v("ErrorEvent")]),e._v(" is thrown (if applicable), the Error is then rendered\ninto an HttpResponse object. How it will be returned is in part determined by\nthe "),t("code",[e._v("respondWithJson")]),e._v(" method in "),t("code",[e._v("config/errors.js")]),e._v(". That method will be\ncalled, and if it returns "),t("code",[e._v("true")]),e._v(" a JSON HttpResponse will be made. Otherwise,\na normal HTML response will be made and sent back to the client. The response\nis further determined by the value of the "),t("code",[e._v("debug")]),e._v(" property in "),t("code",[e._v("config/app.js")]),e._v(".\nIf "),t("code",[e._v("true")]),e._v(", the response (whether JSON or HTML) will have a lot of details.\nIf "),t("code",[e._v("false")]),e._v(", the response will be very basic.")])])}],!1,null,null,null);r.default=o.exports}}]);